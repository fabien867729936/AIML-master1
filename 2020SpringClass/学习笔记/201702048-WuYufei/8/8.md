## Step8 - CNN知识总结
对卷积的前向计算、卷积的反向传播、池化的前向计算与反向传播学习，然后用代码实现一个卷积网络并训练一些实际数据。
### 卷积神经网络的能力
在图像识别和分类领域中取得了非常好的效果，比如识别人脸、物体、交通标识等，这就为机器人、自动驾驶等应用提供了坚实的技术基础。
### 卷积网络的典型结构
如图
<img src="C:/Users/Pangzi/Desktop/Mark/8/image/conv_net.png" />

层级结构：

1. 原始的输入是一张图片，可以是彩色的，也可以是灰度的或黑白的。这里假设是只有一个通道的图片，目的是识别0~9的手写体数字；
2. 第一层卷积，我们使用了4个卷积核，得到了4张feature map；激活函数层没有单独画出来，这里我们紧接着卷积操作使用了Relu激活函数；
3. 第二层是池化，使用了Max Pooling方式，把图片的高宽各缩小一倍，但仍然是4个feature map；
4. 第三层卷积，我们使用了4x6个卷积核，其中4对应着输入通道，6对应着输出通道，从而得到了6张feature map，当然也使用了Relu激活函数；
5. 第四层再次做一次池化，现在得到的图片尺寸只是原始尺寸的四分之一左右；
6. 第五层把第四层的6个图片展平成一维，成为一个fully connected层；
7. 第六层再接一个小一些的fully connected层；
8. 最后接一个softmax函数，判别10个分类。

- 卷积层
- 激活函数层
- 池化层
- 全连接分类层

四个子图，依次展示了：
1. 原图
2. 卷积结果
3. 激活结果
4. 池化结果
<img src="C:/Users/Pangzi/Desktop/Mark/8/image/circle_conv_relu_pool.png" ch="500" />

### 卷积前向计算原理
1. 一般情况下，我们用正方形的卷积核，且为奇数
2. 如果计算出的输出图片尺寸为小数，则取整，不做四舍五入

### 计算反向传播的梯度矩阵

正向公式：

$$Z = W*A+b \tag{0}$$
正向计算过程：

<img src="C:/Users/Pangzi/Desktop/Mark/8/image/conv_forward.png" />

### Cifar 环境搭建

基本步骤

1. 安装Python 3.6（本书中所有案例在Python 3.6上开发测试）
2. 安装CUDA（没有GPU的读者请跳过）
3. 安装cuDNN（没有GPU的读者请跳过）
4. 安装TensorFlow，有GPU硬件的一定要按照GPU版，没有的只能安装CPU版
5. 安装Keras

模型内
1. 先用卷积->激活->卷积->激活->池化->丢弃层，做为第一梯队，卷积核32个；
2. 然后再用卷积->激活->卷积->激活->池化->丢弃层做为第二梯队，卷积核64个；
3. Flatten和Dense相当于把池化的结果转成Nx512的全连接层，N是池化输出的尺寸，被Flatten扁平化了；
4. 再接丢弃层，避免过拟合；
5. 最后接10个神经元的全连接层加Softmax输出。